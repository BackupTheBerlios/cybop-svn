
Q: Why should a tui knowledge template NOT be implemented with properties of abstraction "knowledge" or "encapsulated", as follows:

    <part name="apw_entry" channel="inline" abstraction="character" model="a - Starte Arztpraxis Wiegand (APW) im DOS Emulator (DOSemu)">
        <property name="position" channel="inline" abstraction="integer" model="1,3,0"/>
        <property name="size" channel="inline" abstraction="integer" model="68,1,1"/>
        <property name="shape" channel="inline" abstraction="knowledge" model=".revue.settings.tui.shape"/>
        <property name="layout" channel="inline" abstraction="knowledge" model=".revue.settings.tui.layout"/>
        <property name="background" channel="inline" abstraction="knowledge" model=".revue.settings.tui.menu_item_background"/>
        <property name="foreground" channel="inline" abstraction="knowledge" model=".revue.settings.tui.menu_item_foreground"/>
        <property name="bold" channel="inline" abstraction="knowledge" model=".revue.settings.tui.bold"/>
        <property name="previous" channel="inline" abstraction="character" model=".revue.tui.main_window.menu.exit_entry"/>
        <property name="next" channel="inline" abstraction="character" model=".revue.tui.main_window.menu.backup_entry"/>
        <property name="button_press_action" channel="inline" abstraction="character" model=".revue.logic.functionality.start_apw"/>
    </part>

A1: Because the user interface logic "select_next_part.cybol" and "select_previous_part.cybol",
and potentially other logic templates do access the properties, in order to set their value, for example:

    <part name="assemble_current_element_background" channel="inline" abstraction="operation" model="add">
        <property name="summand_1" channel="inline" abstraction="knowledge" model=".revue.tui.main_window.menu#focus"/>
        <property name="summand_2" channel="inline" abstraction="character" model="#background"/>
        <property name="sum" channel="inline" abstraction="knowledge" model=".revue.temporary.character"/>
        <property name="abstraction" channel="inline" abstraction="character" model="character"/>
    </part>
    <part name="unfocus_background" channel="inline" abstraction="operation" model="copy">
        <property name="source" channel="inline" abstraction="knowledge" model=".revue.settings.tui.menu_item_background"/>
        <property name="destination" channel="inline" abstraction="encapsulated" model=".revue.temporary.character"/>
        <property name="abstraction" channel="inline" abstraction="character" model="character"/>
    </part>

This copies a new background colour value from ".revue.settings.tui.menu_item_background" to the
destination element's property "#background", which is stored in ".revue.temporary.character".
But by copying the colour value to the "#background" property, that property does not contain
a knowledge path of the kind ".revue.settings.tui.menu_item_background" anymore, but rather
a simple colour value like "blue". At that time, the abstraction "knowledge" would NOT be
correct anymore, because the simple colour value is of abstraction "character" instead.

A2: Even if CYBOI-internal procedures implemented a mechanism that tried to retrieve the
real model that a knowledge model path pointed to, this would NOT solve the problem!
The reason is that then not the actual value of the property would be set, but rather
the value of the standard setting (!) that the knowledge path pointed to.

--> RULE to avoid the problems described in A1 and A2:
Single properties of a textual user interface (tui) should not be stored as knowledge path
of abstraction "knowledge" or "encapsulated", but always as primitive values.
To ease application development, however, there is the possibility to use the "super" property,
which permits the inheritance of properties like colours etc. Following an example:

    <part name="main_window" channel="file" abstraction="compound" model="revue/tui/main_window/window.cybol">
        <property name="super" channel="inline" abstraction="knowledge" model=".revue.settings.tui.window"/>
        <property name="position" channel="inline" abstraction="integer" model="0,0,0"/>
        <property name="size" channel="inline" abstraction="integer" model="80,24,1"/>
    </part>

A corresponding settings file may look like this:

<model>
    <part name="shape" channel="inline" abstraction="character" model="rectangle"/>
    <part name="layout" channel="inline" abstraction="character" model="coordinates"/>
    <part name="background" channel="inline" abstraction="character" model="blue"/>
    <part name="foreground" channel="inline" abstraction="character" model="white"/>
    <part name="bold" channel="inline" abstraction="boolean" model="true"/>
</model>

CAUTION! The solution proposed above does not (yet) work satisfyingly.
Only real properties of a knowledge template are created, but NOT those of a super model.
In other words, a created runtime knowledge model that links to a super model does not
own the properties of the super model itself. This causes a problem because logic templates
like "select_next_part.cybol" try to access the properties of a model DIRECTLY, for example
for setting a colour. But if the property does not exist in the model and only in its
super model, then it cannot be set.

--> TODO: For later versions of CYBOI, the super templates/ models must be handled better, either:
1 at creation time in form of a super template whose properties would get instantiated for the model containing the super property
    it is important that the super template should only deliver the properties for the current template,
    but not be created (instantiated) itself (handle this in CYBOL parser or XML translator)
2 at runtime, as it is done now in the tui, which gets the properties of a super model at runtime
    the problem here is that the model does not really itself contain the properties of its super model,
    as described above
==> solution 1 seems desirable, but would need some thinking on how to implement this in CYBOI
==> for now, as temporary solution, the properties are stored redundantly (twice) in the template
    that needs them (for example "menu_item" entries in the resmedicinae-revue menu) and in its super template
