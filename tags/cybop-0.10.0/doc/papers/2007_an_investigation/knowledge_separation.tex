%
% $RCSfile$
%
% Copyright (c) 2005-2006. Christian Heller. All rights reserved.
%
% Permission is granted to copy, distribute and/or modify this document
% under the terms of the GNU Free Documentation License, Version 1.1 or
% any later version published by the Free Software Foundation; with no
% Invariant Sections, with no Front-Cover Texts and with no Back-Cover
% Texts. A copy of the license is included in the section entitled
% "GNU Free Documentation License".
%
% http://www.cybop.net
% - Cybernetics Oriented Programming -
%
% http://www.resmedicinae.org
% - Information in Medicine -
%
% Version: $Revision$ $Date$ $Author$
% Authors: Christian Heller <christian.heller@tuxtax.de>
%

\subsubsection{Knowledge Separation}
\label{knowledge_separation_heading}

In the case of the first prototypes, one could still speak of true
\emph{Implementation}, because design models had to be transferred into another
form of abstract model: the Java programming language source code. Not so in
later versions of \emph{Res Medicinae}.

While the early prototypes represented the classical mix of domain knowledge
and low-level system instructions, that was eliminated later. All knowledge got
\emph{extracted} and was put into special configuration files, in \emph{CYBOL}
format (section \ref{cybol_heading}). Henceforth, these contained not only
settings like font size or colour, as known from standard applications, but the
\emph{whole} domain knowledge, including user interface- and workflow structures.

Following the explanations of section \ref{state_and_logic_heading}, the
\emph{static} knowledge was shared into different models, some representing
\emph{state-}, and others \emph{logic} knowledge. This was very much opposed to
the earlier Java implementations whose classes bundled attributes and methods.

Without the knowledge, the remaining program code looked pretty much like a
skeleton of basic system functionality. Serving as hardware interface, it
concentrated memory- and signal handling in one place -- exactly those things
which section \ref{statics_and_dynamics_heading} called \emph{Dynamics}.
Additionally, that remaining system had the ability to interpret knowledge,
which is why it was called \emph{CYBOI} (interpreter). One could, in some way,
compare it with what the \emph{Java Virtual Machine} (JVM) is for Java, only
that CYBOI processed knowledge given in form of CYBOL templates, which look
different than Java source code.

CYBOI needed an \emph{XML Parser} in order to be able to read the knowledge
contained in CYBOL files. The decision here fell on Apache's \emph{Xerces}
\cite{xerces}, because one of its versions is implemented in Java.
