%
% $RCSfile: definition.tex,v $
%
% Copyright (c) 2004. Christian Heller. All rights reserved.
%
% No copying, altering, distribution or any other actions concerning this
% document, except after explicit permission by the author!
% At some later point in time, this document is planned to be put under
% the GNU FDL license. For now, _everything_ is _restricted_ by the author.
%
% http://www.cybop.net
% - Cybernetics Oriented Programming -
%
% http://www.resmedicinae.org
% - Information in Medicine -
%
% @author Christian Heller <christian.heller@tuxtax.de>
%

\subsection{Definition}
\label{definition_heading}

\emph{Patterns}, in a more correct form called \emph{Software Patterns}, represent
solutions for recurring software design problems and can be understood as
recommendations for how to build software in an elegant way. In the past, more
detailed definitions have been given by meanwhile well-known authors.

Christopher Alexander, an architect and urban planner, writes \cite{alexander}:
\textit{Each pattern describes a problem which occurs over and over again in
our environment, and then describes the core of the solution to that problem,
in such a way that you can use this solution a million times over, without ever
doing it the same way twice.} He gave this definition primarily for problems
occuring in architecture, construction, and urban/regional planning, but it can
be applied in the same manner to software design, as done first by Ward
Cunningham and others \cite{portland}.

The systems designer Swift \cite{designmatrix} sees a pattern as:
\textit{essentially a morphological law, a relationship among parts (pattern
components) within a particular context. Specifically, a pattern expresses a
relationship among parts that resolves problems that would exist if the
relationship were missing. As patterns express these relationships, they are
not formulae or algorithms, but rather loose rules of thumb or heuristics.}

The \emph{Gang of Four} (Erich Gamma et al.) applied Alexander's definition to
object oriented software and created a whole catalogue of design patterns
\cite{gamma1995}. After them, patterns are: \textit{Structured models of
thinking that represent reusable solutions for one-and-the-same design problem.
They shall support the development, maintenance and extension of large software
systems, while being independent from concrete implementation languages.} The
experts identified four basic elements of each pattern: \emph{Name},
\emph{Problem}, \emph{Solution} and \emph{Consequences} (advantages and
disadvantages).

For Frank Buschmann et al., software patterns contain the knowledge of
experienced software engineers and help to improve the quality of decision
making \cite{buschmann}. In his opinion, they are \emph{Problem Solution Pairs},
that is basic solutions for problems that already occured in a similar way before.

Martin Fowler means that: \textit{A pattern is some idea that already was
helpful in a practical context and will probably be useful in other contexts,
too.} \cite{fowler1997}. After him, patterns, however they are written, have
four essential parts: \emph{Context}, \emph{Problem}, \emph{Forces} and
\emph{Solution}.

Depending on their experience, software developers produce good or bad solutions.
One possibility to improve less well-done designs or to extend legacy systems
are \emph{Anti-Patterns} (telling how to go from a problem to a bad design),
or the contrasting \emph{Amelioration Patterns} (telling how to go from a bad-
to a good solution) \cite{portland}. Both help finding patterns in wrong-designed
systems, to improve these.

There are efforts to combine patterns to form a \emph{Pattern Language}, also
called \emph{Pattern System} \cite{buschmann}. Such systems describe
dependencies between patterns, specify rules for pattern combination and show
how patterns can be implemented and used in software development practice.
